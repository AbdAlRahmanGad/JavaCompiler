PARSER_BEGIN(Java)
import java.io.*;
public class Java {
    public static void main(String[] args) throws ParseException {
        Java parser = new Java(System.in);
        checkTokens(parser);

        try{
            FileReader fileReader = new FileReader("VariableDeclerationParserTest.txt");
            Java.ReInit(fileReader);
            parser.Statement();
//                   Token token;
//                    while (true) {
//                        try {
//                            System.out.println(parser.token);
//                            parser.Statement();
//                            System.out.println("Valid statement!");
//                        } catch (ParseException e) {
//                            System.out.println("Parse error: " + e.getMessage());
//                            // Skip to semicolon for error recovery
////                            do {
////                                token = parser.getNextToken();
////                            } while (token.kind != SEMICOLON && token.kind != EOF);
//                        }
//                        // Check if we've reached EOF
//                        token = parser.getNextToken();
//                        if (token.kind == EOF) break;
//                        parser.token = token;  // Push back token for next parse
//                    }
            System.out.println("Parsing completed successfully!");
        } catch (FileNotFoundException e) {
            System.out.println("File not found");
        }
    }
    public static void checkTokens (Java parser) {
       try {
         FileReader fileReader = new FileReader("TokensNoIdentifierORNumberTest.txt");
         FileReader fileReader2 = new FileReader("Tokens.txt");
         parser.ReInit(fileReader);
         while (true) {
           Token t = parser.getNextToken();
           if (t.kind == EOF) break;
           System.out.println("Token: " + t.image + ", Kind: " + t.kind);

         }
         parser.ReInit(fileReader2);
           while (true) {
               Token t = parser.getNextToken();
               if (t.kind == EOF)
                   break;
               System.out.printf("Token: %s at line %d, column %d: \"%s\"%n",
                   token.kind,
                   token.beginLine,
                   token.beginColumn,
                   token.image);
           }
       } catch (FileNotFoundException e) {
         System.out.println("File not found");
       }
    }
}

PARSER_END(Java)



SKIP : { " " | "\t" | "\n" | "\r" | "  "
| <SINGLE_LINE_COMMENT : "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> // ?
| <MULTI_LINE_COMMENT : "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" > // ?
}


// Reserved words
TOKEN : {

< ABSTRACT : "abstract" >
| < CONTINUE : "continue" >
| < FOR : "for" >
| < NEW : "new" >
| < SWITCH : "switch" >
| < ASSERT : "assert" >
| < DEFAULT_ : "default" >
| < GOTO : "goto" >
| < PACKAGE : "package" >
| < SYNCHRONIZED : "synchronized" >
| < BOOLEAN : "boolean" >
| < DO : "do" >
| < IF : "if" >
| < PRIVATE : "private" >
| < THIS : "this" >
| < BREAK : "break" >
| < DOUBLE : "double" >
| < IMPLEMENTS : "implements" >
| < PROTECTED : "protected" >
| < THROW : "throw" >
| < BYTE : "byte" >
| < ELSE : "else" >
| < IMPORT : "import" >
| < PUBLIC : "public" >
| < THROWS : "throws" >
| < CASE : "case" >
| < ENUM : "enum" >
| < INSTANCEOF : "instanceof" >
| < RETURN : "return" >
| < TRANSIENT : "transient" >
| < CATCH : "catch" >
| < EXTENDS : "extends" >
| < INT : "int" >
| < STRING : "String" > // ?
| < EXCEPTION : "Exception" > // ?
| < SHORT : "short" >
| < TRY : "try" >
| < CHAR : "char" >
| < FINAL : "final" >
| < INTERFACE : "interface" >
| < STATIC : "static" >
| < VOID : "void" >
| < CLASS : "class" >
| < FINALLY : "finally" >
| < LONG : "long" >
| < STRICTFP : "strictfp" >
| < VOLATILE : "volatile" >
| < CONST : "const" >
| < FLOAT : "float" >
| < NATIVE : "native" >
| < SUPER : "super" >
| < WHILE : "while" >
}

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < ARROW: "->" >
| < EQ: "==" >
| < GE: ">=" >
| < LE: "<=" >
| < NE: "!=" >
| < SC_AND: "&&" >
| < SC_OR: "||" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//|  < RUNSIGNEDSHIFT: ">>>" >
//  {
//     matchedToken.kind = GT;
//     matchedToken.realKind = RUNSIGNEDSHIFT;
//     input_stream.backup(2);
//  }
//| < RSIGNEDSHIFT: ">>" >
//  {
//     matchedToken.kind = GT;
//     matchedToken.realKind = RSIGNEDSHIFT;
//     input_stream.backup(1);
//  }
| < GT: ">" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

}

// delimiters
TOKEN : {
    <LPAREN : "(" >
| <RPAREN : ")" >
| <LBRACE : "{" >
| <RBRACE : "}" >
| <LBRACKET : "[" >
| <RBRACKET : "]" >
| <SEMICOLON : ";" >
| <COMMA : "," >
| <DOT : "." >
| <ELLIPSIS : "..." >
| <AT : "@">
| < DOUBLECOLON: "::" >

}

/* LITERALS */
TOKEN :
{
< FALSE: "false" >
| < CHAR_LITERAL: "'" (~["'","\\","\n","\r"] | "\\" (["n","t","r","\\","'","\""])) "'" >
| < STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","r","\\","'","\""]))* "\"" >
 | < FLOAT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<F>)
                   | "." (["0"-"9"])+ (<F>)
                   | (["0"-"9"])+ (<F>) >
| < DOUBLE_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<D>)?
                    | "." (["0"-"9"])+ (<D>)?
                    | (["0"-"9"])+ (<D>)>
| < NON_SEALED: "non-sealed" >
| < NULL: "null" >
| < PERMITS: "permits">
| < RECORD: "record" >
| < SEALED: "sealed" >
| < TRUE: "true" >
| < REQUIRES: "requires" >
| < TO: "to" >
| < WITH: "with" >
| < OPEN: "open" >
| < OPENS: "opens" >
| < USES: "uses" >
| < MODULE: "module" >
| < EXPORTS: "exports" >
| < PROVIDES: "provides" >
| < TRANSITIVE: "transitive" >
| < WHEN: "when" >
}

//// Identifiers
TOKEN : {
 <DIGIT : [ "0"-"9" ]>
| <ID : ( <LETTER> | "_" ) ( <LETTER> | <DIGIT> | "_" )*>
| <LETTER : [ "a"-"z", "A"-"Z" ]>

}
MORE : {
< F : ("f" | "F") >
| < D : ("d" | "D") >
}

void Statement() : {}
{
    (LOOKAHEAD(3)
        VariableDeclaration() |
        Assignment()
    )*
    <EOF>
}

void VariableDeclaration() : {}
{
    (
        <INT> |
        <DOUBLE> |
        <CHAR> |
        <STRING> |
        <FLOAT>
    )
    Identifier()
    <SEMICOLON>
}
void Assignment() : {}
{

(
            <STRING> Identifier() <ASSIGN> <STRING_LITERAL> |
            <CHAR> Identifier() <ASSIGN> <CHAR_LITERAL> |
            <INT> Identifier() <ASSIGN> Digits() |
            <DOUBLE> Identifier() <ASSIGN> <DOUBLE_LITERAL> |
            <FLOAT> Identifier() <ASSIGN> <FLOAT_LITERAL>
      )
      <SEMICOLON>
}

void Digits() : {}
{
    (<DIGIT>)+
}
void Identifier() : {}
{
  <ID>
}