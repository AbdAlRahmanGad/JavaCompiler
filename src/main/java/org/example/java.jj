PARSER_BEGIN(Java)
import java.io.*;
public class Java {
    public static void main(String[] args) throws ParseException {
        Java parser = new Java(System.in);
//        checkTokens(parser);
        try{
            FileReader fileReader = new FileReader("VariableDeclerationParserTest.txt");
            Java.ReInit(fileReader);
            parser.Statement();
            System.out.println("Parsing completed successfully!");

            FileReader fileReader2 = new FileReader("excepretion.txt");
            Java.ReInit(fileReader2);
            parser.compTest();
            System.out.println("Parsing Comparision completed successfully!");

            FileReader fileReader3 = new FileReader("ifElse.txt");
            Java.ReInit(fileReader3);
            parser.IfStatementTest();
            System.out.println("Parsing If Statement completed successfully!");

            FileReader fileReader4 = new FileReader("while.txt");
            Java.ReInit(fileReader4);
            parser.testWhile();
            System.out.println("Parsing While Statement completed successfully!");

            FileReader fileReader5 = new FileReader("for.txt");
            Java.ReInit(fileReader5);
            parser.ForTest();
            System.out.println("Parsing For Statement completed successfully!");
        } catch (FileNotFoundException e) {
            System.out.println("File not found");
        }
    }
    public static void checkTokens (Java parser) {
       try {
         FileReader fileReader = new FileReader("TokensNoIdentifierORNumberTest.txt");
         FileReader fileReader2 = new FileReader("Tokens.txt");
         parser.ReInit(fileReader);
         while (true) {
           Token t = parser.getNextToken();
           if (t.kind == EOF) break;
           System.out.println("Token: " + t.image + ", Kind: " + t.kind);

         }
         parser.ReInit(fileReader2);
           while (true) {
               Token t = parser.getNextToken();
               if (t.kind == EOF)
                   break;
               System.out.printf("Token: %s at line %d, column %d: \"%s\"%n",
                   token.kind,
                   token.beginLine,
                   token.beginColumn,
                   token.image);
           }
       } catch (FileNotFoundException e) {
         System.out.println("File not found");
       }
    }
}


PARSER_END(Java)



SKIP : { " " | "\t" | "\n" | "\r" | "  "
| <SINGLE_LINE_COMMENT : "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> // ?
| <MULTI_LINE_COMMENT : "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" > // ?
}


// Reserved words
TOKEN : {

< ABSTRACT : "abstract" >
| < CONTINUE : "continue" >
| < FOR : "for" >
| < NEW : "new" >
| < SWITCH : "switch" >
| < ASSERT : "assert" >
| < DEFAULT_ : "default" >
| < GOTO : "goto" >
| < PACKAGE : "package" >
| < SYNCHRONIZED : "synchronized" >
| < BOOLEAN : "boolean" >
| < DO : "do" >
| < IF : "if" >
| < PRIVATE : "private" >
| < THIS : "this" >
| < BREAK : "break" >
| < DOUBLE : "double" >
| < IMPLEMENTS : "implements" >
| < PROTECTED : "protected" >
| < THROW : "throw" >
| < BYTE : "byte" >
| < ELSE : "else" >
| < IMPORT : "import" >
| < PUBLIC : "public" >
| < THROWS : "throws" >
| < CASE : "case" >
| < ENUM : "enum" >
| < INSTANCEOF : "instanceof" >
| < RETURN : "return" >
| < TRANSIENT : "transient" >
| < CATCH : "catch" >
| < EXTENDS : "extends" >
| < INT : "int" >
| < STRING : "String" > // ?
| < EXCEPTION : "Exception" > // ?
| < SHORT : "short" >
| < TRY : "try" >
| < CHAR : "char" >
| < FINAL : "final" >
| < INTERFACE : "interface" >
| < STATIC : "static" >
| < VOID : "void" >
| < CLASS : "class" >
| < FINALLY : "finally" >
| < LONG : "long" >
| < STRICTFP : "strictfp" >
| < VOLATILE : "volatile" >
| < CONST : "const" >
| < FLOAT : "float" >
| < NATIVE : "native" >
| < SUPER : "super" >
| < WHILE : "while" >
}

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < ARROW: "->" >
| < EQ: "==" >
| < GE: ">=" >
| < LE: "<=" >
| < NE: "!=" >
| < SC_AND: "&&" >
| < SC_OR: "||" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
//|  < RUNSIGNEDSHIFT: ">>>" >
//  {
//     matchedToken.kind = GT;
//     matchedToken.realKind = RUNSIGNEDSHIFT;
//     input_stream.backup(2);
//  }
//| < RSIGNEDSHIFT: ">>" >
//  {
//     matchedToken.kind = GT;
//     matchedToken.realKind = RSIGNEDSHIFT;
//     input_stream.backup(1);
//  }
| < GT: ">" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >

}

// delimiters
TOKEN : {
    <LPAREN : "(" >
| <RPAREN : ")" >
| <LBRACE : "{" >
| <RBRACE : "}" >
| <LBRACKET : "[" >
| <RBRACKET : "]" >
| <SEMICOLON : ";" >
| <COMMA : "," >
| <DOT : "." >
| <ELLIPSIS : "..." >
| <AT : "@">
| < DOUBLECOLON: "::" >

}

/* LITERALS */
TOKEN :
{
< FALSE: "false" >
| < CHAR_LITERAL: "'" (~["'","\\","\n","\r"] | "\\" (["n","t","r","\\","'","\""])) "'" >
| < STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","r","\\","'","\""]))* "\"" >
 | < FLOAT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<F>)
                   | "." (["0"-"9"])+ (<F>)
                   | (["0"-"9"])+ (<F>) >
| < DOUBLE_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<D>)?
                    | "." (["0"-"9"])+ (<D>)?
                    | (["0"-"9"])+ (<D>)>
| < NON_SEALED: "non-sealed" >
| < NULL: "null" >
| < PERMITS: "permits">
| < RECORD: "record" >
| < SEALED: "sealed" >
| < TRUE: "true" >
| < REQUIRES: "requires" >
| < TO: "to" >
| < WITH: "with" >
| < OPEN: "open" >
| < OPENS: "opens" >
| < USES: "uses" >
| < MODULE: "module" >
| < EXPORTS: "exports" >
| < PROVIDES: "provides" >
| < TRANSITIVE: "transitive" >
| < WHEN: "when" >
}

//// Identifiers
TOKEN : {
 <DIGIT : [ "0"-"9" ]>
| <ID : ( <LETTER> | "_" ) ( <LETTER> | <DIGIT> | "_" )*>
| <LETTER : [ "a"-"z", "A"-"Z" ]>
}

MORE : {
< F : ("f" | "F") >
| < D : ("d" | "D") >
}

void Statement() : {}
{
    (LOOKAHEAD(3)
        VariableDeclaration() |
        Assignment() |
        IfStatement() |
        WhileStatement() |
        ForStatement() |
        AssignmentWithNoSemicolon() <SEMICOLON> |
        IncrementDecrement() <SEMICOLON>
    )*
    <EOF>
}

void nestedStatement() : {}
{
    (LOOKAHEAD(4)
        VariableDeclaration() |
        Assignment() |
        WhileStatement() |
        IfStatement() |
        ForStatement() |
        AssignmentWithNoSemicolon() <SEMICOLON> |
        IncrementDecrement() <SEMICOLON>
    )
}

void testWhile() : {}
{
    (WhileStatement())*
    <EOF>
}
void WhileStatement() : {}
{
    <WHILE> <LPAREN> Expression() <RPAREN>
     (nestedStatement() | <LBRACE> (nestedStatement())* <RBRACE>)
}

void ForTest() : {}
{
    (ForStatement())*
    <EOF>
}

void ForStatement() : {}
{

    <FOR> <LPAREN>
        (ForInit())? <SEMICOLON>
        (Expression())? <SEMICOLON>
        (ForUpdate())?
    <RPAREN>
    (<LBRACE> (nestedStatement())* <RBRACE> | nestedStatement())
}


void ForInit() : {}
{
    LOOKAHEAD(2)
    VariableDeclarationWithNoSemicolon()
    (<COMMA> VariableDeclarationAfterComma() | AssignmentWithNoSemicolon())*
    |
    AssignmentWithNoSemicolon()
    (<COMMA> AssignmentWithNoSemicolon())*
}

void ForUpdate() : {}
{
    LOOKAHEAD(2)
    AssignmentWithNoSemicolon() |
    IncrementDecrement()
    (<COMMA> IncrementDecrement() | AssignmentWithNoSemicolon())*
}

void IncrementDecrement() : {}
{
    LOOKAHEAD(3)
    <ID> (<INCR> | <DECR>) |
    (<INCR> | <DECR>) <ID> |
    <ID> (
        <PLUSASSIGN> |
        <MINUSASSIGN> |
        <STARASSIGN> |
        <SLASHASSIGN> |
        <ANDASSIGN> |
        <ORASSIGN> |
        <XORASSIGN> |
        <REMASSIGN> |
        <LSHIFTASSIGN> |
        <RSIGNEDSHIFTASSIGN> |
        <RUNSIGNEDSHIFTASSIGN>
    ) MathExpressionForLoop()
}

void VariableDeclarationWithNoSemicolon() : {}
{
    (
        <INT> |
        <DOUBLE> |
        <CHAR> |
        <STRING> |
        <FLOAT>
    )
    Identifier()
    [<ASSIGN> Expression()]
}
void VariableDeclarationAfterComma() : {}
{
    Identifier()
    [<ASSIGN> Expression()]
}

void AssignmentWithNoSemicolon() : {}
{
    <ID> <ASSIGN> Expression()
}

void IfStatementTest() : {}
{
   (IfStatement())*
   <EOF>
}

void compTest() : {}
{
    (Expression())*
    <EOF>
}

void IfStatement() : {}
{
    <IF> <LPAREN> Expression() <RPAREN>
     ( <LBRACE> (nestedStatement())* <RBRACE> | nestedStatement())
     (LOOKAHEAD(3)<ELSE> (<LBRACE> (nestedStatement())* <RBRACE> | nestedStatement()))?
}

void MathExpression() : {}
{
    Term() ( <PLUS> Term() | <MINUS> Term() )*
}

void Term() : {}
{
    Factor() (<STAR> Factor() | <SLASH> Factor())*
}

void Factor() : {}
{
    Digits() |
    <DOUBLE_LITERAL> |
    <FLOAT_LITERAL> |
    <CHAR_LITERAL> |
    <STRING_LITERAL> |
    <TRUE> |
    <FALSE> |
    <LPAREN> Expression() <RPAREN> |
    <ID>
}

void MathExpressionForLoop() : {}
{
    TermForLoop() ( <PLUS> TermForLoop() | <MINUS> TermForLoop() )*
}

void TermForLoop() : {}
{
    FactorForLoop() (<STAR> FactorForLoop() | <SLASH> FactorForLoop())*
}

void FactorForLoop() : {}
{
    Digits() |
    <DOUBLE_LITERAL> |
    <FLOAT_LITERAL> |
    <CHAR_LITERAL> |
    <STRING_LITERAL> |
    <TRUE> |
    <FALSE> |
    <LPAREN> MathExpressionForLoop() <RPAREN> |
    <ID>
}

void Expression() : {}
{
    ComparisonExpression() ( LOOKAHEAD(3) <SC_AND> Expression() |
    <SC_OR> Expression())*
}

void ComparisonExpression() : {}
{
    MathExpression() (
        <EQ> MathExpression() |
        <NE> MathExpression() |
        <LT> MathExpression() |
        <GT> MathExpression() |
        <LE> MathExpression() |
        <GE> MathExpression()
    )*
}

void VariableDeclaration() : {}
{
    (
        <INT> |
        <DOUBLE> |
        <CHAR> |
        <STRING> |
        <FLOAT>
    )
    Identifier()
    <SEMICOLON>
}

void Assignment() : {}
{

(
        <STRING> Identifier() <ASSIGN> (LOOKAHEAD(2)(MathExpression())+ | <STRING_LITERAL> ) |
        <CHAR> Identifier() <ASSIGN> (<CHAR_LITERAL>| Identifier()) |
        <INT> Identifier() <ASSIGN> (LOOKAHEAD(3)Digits() | (MathExpression())+) |
        <DOUBLE> Identifier() <ASSIGN> (LOOKAHEAD(2)<DOUBLE_LITERAL> | (MathExpression())+) |
        <FLOAT> Identifier() <ASSIGN> (LOOKAHEAD(2)<FLOAT_LITERAL>  | (MathExpression())+)
      )
      <SEMICOLON>
}

void Digits() : {}
{
    (<DIGIT>)+
}

void Identifier() : {}
{
  <ID>
}